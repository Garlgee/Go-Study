### **面试高频问题小结**

1. **数组 vs 切片**
2. **切片扩容机制**
3. **切片共享底层数组的副作用**
4. **如何限制切片容量**
5. **深拷贝与 `append` 行为**
6. **索引越界与 `nil` 切片的处理**

### **数组与切片基础**

1. **数组与切片的区别是什么？**
   - **数组**：固定长度，声明时长度是类型的一部分。
   - **切片**：动态长度，是对底层数组的抽象，支持动态扩容。

2. **如何判断数组和切片的零值？**
   - 数组的零值为所有元素的零值，如 `[3]int{}` 是 `[0, 0, 0]`。
   - 切片的零值为 `nil`，`len` 和 `cap` 都是 0。

---

### **切片操作**

3. **以下代码输出是什么？为什么？**
   ```go
   s := []int{1, 2, 3, 4, 5}
   sub := s[1:3]
   sub[0] = 99
   fmt.Println(s)
   ```
   **解答**：`[1, 99, 3, 4, 5]`
   - `sub` 是 `s` 的切片，修改 `sub` 会影响底层数组。

4. **切片扩容机制是如何工作的？**
   - 当切片容量不足时，会分配一个新的底层数组。通常扩容为原容量的 2 倍，但具体策略可能会因实现而异。

---

### **容量与扩容**

5. **解释以下代码：**
   ```go
   s := []int{1, 2, 3, 4, 5}
   s = append(s, 6, 7, 8)
   ```
   **解答**：
   - 如果切片 `s` 的底层数组容量不足，会分配一个新的数组并拷贝原数组数据，原 `s` 的其他切片不会受影响。

6. **如何限制切片容量？为什么要这样做？**
   ```go
   s := []int{1, 2, 3, 4, 5}
   sub := s[1:3:3] // 限制容量
   ```
   - 使用 `low:high:max` 语法，可以限制切片 `sub` 的容量，防止影响原数组。

---

### **深拷贝与浅拷贝**

7. **如何实现切片的深拷贝？**
   ```go
   original := []int{1, 2, 3}
   copySlice := make([]int, len(original))
   copy(copySlice, original)
   ```
   - 使用 `copy` 函数实现深拷贝，不会共享底层数组。

---

### **性能与优化**

8. **切片与数组在性能上的差异？**
   - **数组**：固定长度，更高效，适合长度已知且不变的情况。
   - **切片**：灵活，动态扩容可能带来额外开销。

---

### **边界与异常**

9. **以下代码是否会引发错误？为什么？**
   ```go
   s := []int{1, 2, 3}
   fmt.Println(s[3])
   ```
   **解答**：是，`panic`。切片索引越界，访问 `s[3]` 会触发运行时错误。

10. **以下代码的输出是什么？**
    ```go
    var s []int
    fmt.Println(len(s), cap(s), s == nil)
    ```
    **解答**：`0 0 true`
    - `nil` 切片的长度和容量都是 0，并且与 `nil` 相等。

---

### **常见陷阱**

11. **`append` 在不同场景下的表现：**
    ```go
     s := []int{1, 2, 3, 4} // 底层数组容量为 4
	 sub := s[:2]           // sub = [1, 2]，长度为 2，容量为 4
	 fmt.Printf("s len=%d cap=%d slice=%v\n", len(s), cap(s),  s)
	 fmt.Printf("sub len=%d cap=%d slice=%v\n", len(sub), cap (sub), sub)
 
	 // 第一次 append，不超出容量，修改底层数组
	 sub = append(sub, 99) // sub = [1, 2, 99]，底层数组变为  [1, 2, 99, 4]
	 fmt.Println("After first append:")
	 fmt.Println("s:", s)     // 输出: s: [1, 2, 99, 4]
	 fmt.Println("sub:", sub) // 输出: sub: [1, 2, 99]
 
	 // 第二次 append，超出容量，分配新数组
	 sub = append(sub, 88, 77) // sub = [1, 2, 99, 88, 77]，分 配新数组
	 fmt.Println("\nAfter second append:")
	 fmt.Println("s:", s)     // 输出: s: [1, 2, 99, 4]，不受影 响
	 fmt.Println("sub:", sub) // 输出: sub: [1, 2, 99, 88, 77]
    ```
    **解答**：
    - 如果 `append` 未超出 `sub` 的容量，`s` 会变。
    - 如果超出，则会分配新数组，`s` 保持不变。

12. **如何确保切片扩容后不会影响原始数据？**
    - 在追加元素时，可以先 `copy` 到新切片，避免影响共享底层数组的其他切片。

---